<?php

declare(strict_types=1);

namespace Stancl\Tenancy\Overrides;

use BackedEnum;
use Illuminate\Routing\UrlGenerator;
use Illuminate\Support\Arr;
use InvalidArgumentException;
use Stancl\Tenancy\Resolvers\PathTenantResolver;

/**
 * This class is used in place of the default UrlGenerator when UrlGeneratorBootstrapper is enabled.
 *
 * TenancyUrlGenerator does two extra things:
 * 1. Autofill the {tenant} parameter in the tenant context with the current tenant if $passTenantParameterToRoutes is enabled (enabled by default)
 * 2. Prepend the route name with `tenant.` (or the configured prefix) if $prefixRouteNames is enabled (disabled by default)
 *
 * Both of these can be skipped by passing the $bypassParameter (`['central' => true]` by default)
 */
class TenancyUrlGenerator extends UrlGenerator
{
    /**
     * Parameter which bypasses the behavior modification of route() and temporarySignedRoute().
     *
     * E.g. route('tenant') => app.test/{tenant}/tenant (or app.test/tenant?tenant=tenantKey if the route doesn't accept the tenant parameter)
     * route('tenant', [$bypassParameter => true]) => app.test/tenant.
     */
    public static string $bypassParameter = 'central';

    /**
     * Determine if the route names passed to `route()` or `temporarySignedRoute()`
     * should get prefixed with the tenant route name prefix.
     *
     * This is useful when using path identification with packages that generate URLs,
     * like Jetstream, so that you don't have to manually prefix route names passed to each route() call.
     */
    public static bool $prefixRouteNames = false;

    /**
     * Determine if the tenant parameter should get passed
     * to the links generated by `route()` or `temporarySignedRoute()` whenever available
     * (enabled by default â€“ works with both path and query string identification).
     *
     * With path identification, you can disable this and use URL::defaults() instead (as an alternative solution).
     */
    public static bool $passTenantParameterToRoutes = true;

    /**
     * Override the route() method so that the route name gets prefixed
     * and the tenant parameter gets added when in tenant context.
     */
    public function route($name, $parameters = [], $absolute = true)
    {
        if ($name instanceof BackedEnum && ! is_string($name = $name->value)) { // @phpstan-ignore function.impossibleType
            throw new InvalidArgumentException('Attribute [name] expects a string backed enum.');
        }

        [$name, $parameters] = $this->prepareRouteInputs($name, Arr::wrap($parameters)); // @phpstan-ignore argument.type

        $url = parent::route($name, $parameters, $absolute);

        if (isset($parameters[PathTenantResolver::tenantParameterName()])) {
            /**
             * Ensure the tenant key appears in the final URL only once.
             * This adjustment is necessary when RootUrlBootstrapper is enabled (and used as intended).
             *
             * When RootUrlBootstrapper adds the tenant key to the root URL:
             * - The root URL includes the tenant key (http://localhost/tenantfoo).
             * - Passing the tenant key as a parameter to `parent::route()` adds it again, causing duplication.
             *
             * To fix this:
             * - For relative URLs: Include only the part AFTER the tenant key.
             * - For absolute URLs: Rebuild the URL so that the tenant key is included exactly once.
             */
            $tenantKey = $parameters[PathTenantResolver::tenantParameterName()];

            // Separate the URL into parts before the first and after the last tenant key
            $urlBeforeTenantKey = str($url)->before($tenantKey)->toString(); // e.g. "http://localhost/"
            $urlAfterTenantKey = str($url)->afterLast($tenantKey)->toString(); // e.g. "/home"

            if (! $absolute && str(url('/'))->contains($tenantKey)) {
                // For relative URLs, return only the part after the tenant key
                return $urlAfterTenantKey;
            }

            // Reconstruct the URL with the tenant key appearing exactly once
            return $urlBeforeTenantKey . $tenantKey . $urlAfterTenantKey;
        }

        return $url;
    }

    /**
     * Override the temporarySignedRoute() method so that the route name gets prefixed
     * and the tenant parameter gets added when in tenant context.
     */
    public function temporarySignedRoute($name, $expiration, $parameters = [], $absolute = true)
    {
        if ($name instanceof BackedEnum && ! is_string($name = $name->value)) { // @phpstan-ignore function.impossibleType
            throw new InvalidArgumentException('Attribute [name] expects a string backed enum.');
        }

        [$name, $parameters] = $this->prepareRouteInputs($name, Arr::wrap($parameters)); // @phpstan-ignore argument.type

        return parent::temporarySignedRoute($name, $expiration, $parameters, $absolute);
    }

    /**
     * Return bool indicating if the bypass parameter was in $parameters.
     */
    protected function routeBehaviorModificationBypassed(mixed $parameters): bool
    {
        if (isset($parameters[static::$bypassParameter])) {
            return (bool) $parameters[static::$bypassParameter];
        }

        return false;
    }

    /**
     * Takes a route name and an array of parameters to return the prefixed route name
     * and the route parameters with the tenant parameter added.
     *
     * To skip these modifications, pass the bypass parameter in route parameters.
     * Before returning the modified route inputs, the bypass parameter is removed from the parameters.
     */
    protected function prepareRouteInputs(string $name, array $parameters): array
    {
        if (! $this->routeBehaviorModificationBypassed($parameters)) {
            $name = $this->prefixRouteName($name);
            $parameters = $this->addTenantParameter($parameters);
        }

        // Remove bypass parameter from the route parameters
        unset($parameters[static::$bypassParameter]);

        return [$name, $parameters];
    }

    /**
     * If $prefixRouteNames is true, prefix the passed route name.
     */
    protected function prefixRouteName(string $name): string
    {
        $tenantPrefix = PathTenantResolver::tenantRouteNamePrefix();

        if (static::$prefixRouteNames && ! str($name)->startsWith($tenantPrefix)) {
            $name = str($name)->after($tenantPrefix)->prepend($tenantPrefix)->toString();
        }

        return $name;
    }

    /**
     * If `tenant()` isn't null, add tenant paramter to the passed parameters.
     */
    protected function addTenantParameter(array $parameters): array
    {
        return tenant() && static::$passTenantParameterToRoutes ? array_merge($parameters, [PathTenantResolver::tenantParameterName() => tenant()->getTenantKey()]) : $parameters;
    }
}
